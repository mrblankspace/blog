<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>BLANKSPACE&#39;S BLOG</title>
  
  <subtitle>张波的个人博客，java，大数据方向</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-24T05:51:54.728Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>blankspace</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>这是为什么呢</title>
    <link href="http://yoursite.com/2019/03/24/%E8%BF%99%E6%98%AF%E4%B8%BA%E4%BB%80%E4%B9%88%E5%91%A2/"/>
    <id>http://yoursite.com/2019/03/24/这是为什么呢/</id>
    <published>2019-03-24T05:47:02.000Z</published>
    <updated>2019-03-24T05:51:54.728Z</updated>
    
    <content type="html"><![CDATA[<p>为毛随便来个女人都可以打乱我的生活，我的情商真是太低了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为毛随便来个女人都可以打乱我的生活，我的情商真是太低了。&lt;/p&gt;

      
    
    </summary>
    
      <category term="垃圾场" scheme="http://yoursite.com/categories/%E5%9E%83%E5%9C%BE%E5%9C%BA/"/>
    
    
      <category term="吐槽" scheme="http://yoursite.com/tag/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>jvm-字节码文件</title>
    <link href="http://yoursite.com/2019/03/24/jvm-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6/"/>
    <id>http://yoursite.com/2019/03/24/jvm-字节码文件/</id>
    <published>2019-03-24T05:33:51.000Z</published>
    <updated>2019-03-24T06:02:21.592Z</updated>
    
    <content type="html"><![CDATA[<h2 id="下面解析一段源代码"><a href="#下面解析一段源代码" class="headerlink" title="下面解析一段源代码"></a>下面解析一段源代码</h2><ul><li>jdk版本 1.8</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class TestClass &#123;</span><br><span class="line">    private int m;</span><br><span class="line">    private Integer i;</span><br><span class="line">    public int inc()&#123;</span><br><span class="line">//        long a = 0;</span><br><span class="line">//</span><br><span class="line">//        long b = 0;</span><br><span class="line">//</span><br><span class="line">//        Integer c = 0;</span><br><span class="line"> //       i++;    //拆箱intvalue 装箱valueof</span><br><span class="line">        return m+1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TestClass()&#123;</span><br><span class="line">       // i = 2;   //装箱</span><br><span class="line">     //   i.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//    public static void main(String[] args)&#123;</span><br><span class="line">//        System.out.println(new FieldResolution().getClass().getClassLoader());</span><br><span class="line">//        System.out.println(new String(&quot;aaaaa&quot;).getClass().getClassLoader());</span><br><span class="line">//        System.out.println(new Date().getClass().getClassLoader());</span><br><span class="line">//    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译后的字节码文件"><a href="#编译后的字节码文件" class="headerlink" title="编译后的字节码文件"></a>编译后的字节码文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">Classfile /media/zhangbo/resource/javaProgram/JVM/src/cn/swpu/test/TestClass.class</span><br><span class="line">Last modified 2019-3-23; size 326 bytes</span><br><span class="line">MD5 checksum 6933bec5f3baf9f936b45a4704ca4d44</span><br><span class="line">Compiled from &quot;TestClass.java&quot;</span><br><span class="line">public class cn.swpu.test.TestClass</span><br><span class="line">minor version: 0</span><br><span class="line">major version: 52</span><br><span class="line">flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">#1 = Fieldref #3.#17 // cn/swpu/test/TestClass.m:I</span><br><span class="line">#2 = Methodref #4.#18 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#3 = Class #19 // cn/swpu/test/TestClass</span><br><span class="line">#4 = Class #20 // java/lang/Object</span><br><span class="line">#5 = Utf8 m              </span><br><span class="line">#6 = Utf8 I</span><br><span class="line">#7 = Utf8 i</span><br><span class="line">#8 = Utf8 Ljava/lang/Integer;</span><br><span class="line">#9 = Utf8 inc</span><br><span class="line">#10 = Utf8 ()I</span><br><span class="line">#11 = Utf8 Code</span><br><span class="line">#12 = Utf8 LineNumberTable</span><br><span class="line">#13 = Utf8 &lt;init&gt;</span><br><span class="line">#14 = Utf8 ()V</span><br><span class="line">#15 = Utf8 SourceFile</span><br><span class="line">#16 = Utf8 TestClass.java</span><br><span class="line">#17 = NameAndType #5:#6 // m:I</span><br><span class="line">#18 = NameAndType #13:#14 // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#19 = Utf8 cn/swpu/test/TestClass</span><br><span class="line">#20 = Utf8 java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">public int inc();</span><br><span class="line">descriptor: ()I</span><br><span class="line">flags: ACC_PUBLIC</span><br><span class="line">Code:</span><br><span class="line">stack=2, locals=1, args_size=1</span><br><span class="line">0: aload_0</span><br><span class="line">1: getfield #1 // Field m:I</span><br><span class="line">4: iconst_1</span><br><span class="line">5: iadd</span><br><span class="line">6: ireturn</span><br><span class="line">LineNumberTable:</span><br><span class="line">line 14: 0</span><br><span class="line"></span><br><span class="line">public cn.swpu.test.TestClass();</span><br><span class="line">descriptor: ()V</span><br><span class="line">flags: ACC_PUBLIC</span><br><span class="line">Code:</span><br><span class="line">stack=1, locals=1, args_size=1</span><br><span class="line">0: aload_0</span><br><span class="line">1: invokespecial #2 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">4: return</span><br><span class="line">LineNumberTable:</span><br><span class="line">line 18: 0</span><br><span class="line">line 21: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码文件前面是一些校验和信息，jdk版本信息，class文件的访问权限信息</p><h2 id="理解–constant-pool"><a href="#理解–constant-pool" class="headerlink" title="理解–constant pool"></a>理解–constant pool</h2><h3 id="1-Fieldref-3-17-cn-swpu-test-TestClass-m-I"><a href="#1-Fieldref-3-17-cn-swpu-test-TestClass-m-I" class="headerlink" title="#1 = Fieldref #3.#17 // cn/swpu/test/TestClass.m:I"></a>#1 = Fieldref #3.#17 // cn/swpu/test/TestClass.m:I</h3><p>第一个常量 它表示对一个类变量的引用，一号常量又引用了#3号常量和#17号常量，分别表示它的所属类，m是它的名称，I是它的类型描述符，表示int。</p><p>这里发现源代码中有Integer类型的变量i，但是字节码文件中并没有生成对他的Contant_field_ref常量，原因在代码中并没又使用i变量，所以被编译器优化掉了。</p><h3 id="2-Methodref-4-18-java-lang-Object-”“-V"><a href="#2-Methodref-4-18-java-lang-Object-”“-V" class="headerlink" title="#2 = Methodref #4.#18 // java/lang/Object.”“:()V"></a>#2 = Methodref #4.#18 // java/lang/Object.”<init>“:()V</init></h3><p>编译器在字节码文件中添加了一个返回值为void，名称为<init>的方法，这个方法是属于Object类的。</init></p><p>这个类是源码中没有的，编译器为我们添加的实例构造器。</p><p>这时我们的实例构造器是空的，为它添加上一句代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public TestClass()&#123;</span><br><span class="line">    i = 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public cn.swpu.test.TestClass();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #2                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: iconst_2</span><br><span class="line">         6: invokestatic  #3                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span><br><span class="line">         9: putfield      #4                  // Field i:Ljava/lang/Integer;</span><br><span class="line">        12: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 18: 0</span><br><span class="line">        line 19: 4</span><br><span class="line">        line 22: 12</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到编译器把调用父类构造器的代码，和TestClass本身构造器的代码合并了。那么多个重载构造器会出现什么情况呢</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public TestClass()&#123;</span><br><span class="line">    i = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TestClass(Integer i) &#123;</span><br><span class="line">    this.i = i;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 编译后……</p><p>从 3 句 incokespecial 语句可以看到，实际上构造器的代码都被放进了<init>实例构造器中。</init></p><p>#3 = Class #19 // cn/swpu/test/TestClass   引用了19号utf8编码的字符串 “cn/swpu/test/TestClass”<br>#4 = Class #20 // java/lang/Object 引用了20号utf8编码的字符串“ java/lang/Object”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;下面解析一段源代码&quot;&gt;&lt;a href=&quot;#下面解析一段源代码&quot; class=&quot;headerlink&quot; title=&quot;下面解析一段源代码&quot;&gt;&lt;/a&gt;下面解析一段源代码&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;jdk版本 1.8&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="jvm" scheme="http://yoursite.com/categories/jvm/"/>
    
      <category term="class文件" scheme="http://yoursite.com/categories/jvm/class%E6%96%87%E4%BB%B6/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tag/%E6%80%BB%E7%BB%93/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tag/jvm/"/>
    
  </entry>
  
  <entry>
    <title>国庆后</title>
    <link href="http://yoursite.com/2018/10/07/%E5%9B%BD%E5%BA%86%E5%90%8E/"/>
    <id>http://yoursite.com/2018/10/07/国庆后/</id>
    <published>2018-10-07T02:40:41.000Z</published>
    <updated>2018-10-06T21:01:07.440Z</updated>
    
    <content type="html"><![CDATA[<h2 id="找找问题"><a href="#找找问题" class="headerlink" title="找找问题"></a>找找问题</h2><p>&emsp;&emsp;第三个国庆，一如既往的待在了学校，人变得慵懒了许多。</p><h2 id="定个计划-10-8-11-11"><a href="#定个计划-10-8-11-11" class="headerlink" title="定个计划 10.8-11.11"></a>定个计划 10.8-11.11</h2><p>&emsp;&emsp;调整状态，重点转移为软考。快速复习基础学科（设计模式、计算机系统基础、数据结构与算法等）</p><ul><li>时间：下午的课外时间+晚上（到9点）</li><li>地点: 图书馆</li></ul><p>&emsp;&emsp;课程学习，这个时间段安卓和需求分析应该会结课了，伴随而来的结课考试，应该要花点时间准备</p><ul><li>时间: 上午的课外时间</li><li>地点: 团队</li></ul><h4 id="计划之外的情况"><a href="#计划之外的情况" class="headerlink" title="计划之外的情况"></a>计划之外的情况</h4><p>&emsp;&emsp;实验室的老师可能会安排任务，其他科目的作业等。（根据相应情况在白天的课后时间作出调整，尽量不影响到晚上的时间）</p><h2 id="短期目标"><a href="#短期目标" class="headerlink" title="短期目标"></a><strong>短期目标</strong></h2><p>&emsp;&emsp;通过软考，</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;找找问题&quot;&gt;&lt;a href=&quot;#找找问题&quot; class=&quot;headerlink&quot; title=&quot;找找问题&quot;&gt;&lt;/a&gt;找找问题&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;第三个国庆，一如既往的待在了学校，人变得慵懒了许多。&lt;/p&gt;
&lt;h2 id=&quot;定个计划-10-8-1
      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tag/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>JVM小结</title>
    <link href="http://yoursite.com/2018/09/15/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2018/09/15/垃圾回收/</id>
    <published>2018-09-15T03:31:40.000Z</published>
    <updated>2018-10-06T21:29:07.443Z</updated>
    
    <content type="html"><![CDATA[<p>﻿﻿# JVM知识梳理(待完善)<br>&emsp;&emsp;学习两周深入理解JVM,整理一下JVM基础知识结构<br>![JVM知识框架]<br>&emsp;&emsp;我把JVM理解成一种管理工具，当每个程序启动的时候，实例化一个JVM，为其划分一片内存空间</p><h2 id="jvm内存结构"><a href="#jvm内存结构" class="headerlink" title="jvm内存结构"></a>jvm内存结构</h2><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><ol><li>垃圾回收算法</li><li>HotSpot的算法实现</li><li><p>垃圾收集器</p><ul><li>Serial收集器<br><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174239719-1127409322.png" alt="此处输入图片的描述"><blockquote><p>鸡肋 采用复制算法工作在新生代 单线程收集，且收集器执行的时候应用程序必须停下来等待，适用于一些小的桌面应用程序，这些等待时间可以忽略的应用</p></blockquote></li><li>SerialOld收集器<blockquote><p>与Seriral不同的是  如它的名字，SerialOld工作在老年代，采用标记-整理算法</p></blockquote></li><li><p>ParNew收集器<br><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174241188-1502278645.png" alt="此处输入图片的描述"></p><blockquote><p>Serial的多线程版本 新生代收集器 并发收集器 复制算法</p></blockquote></li><li><p>ParOld收集器</p><blockquote></blockquote></li><li>CMS收集器<blockquote><p><img src="http://images2015.cnblogs.com/blog/331425/201606/331425-20160624174245500-1388590060.png" alt="此处输入图片的描述"></p></blockquote></li></ul></li></ol><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h2 id="class文件"><a href="#class文件" class="headerlink" title="class文件"></a>class文件</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;﻿﻿# JVM知识梳理(待完善)&lt;br&gt;&amp;emsp;&amp;emsp;学习两周深入理解JVM,整理一下JVM基础知识结构&lt;br&gt;![JVM知识框架]&lt;br&gt;&amp;emsp;&amp;emsp;我把JVM理解成一种管理工具，当每个程序启动的时候，实例化一个JVM，为其划分一片内存空间&lt;/p&gt;

      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结 规划" scheme="http://yoursite.com/tag/%E6%80%BB%E7%BB%93-%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>hibernate笔记</title>
    <link href="http://yoursite.com/2018/08/26/hibernate%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/08/26/hibernate笔记/</id>
    <published>2018-08-26T01:37:16.000Z</published>
    <updated>2018-08-26T02:40:25.040Z</updated>
    
    <content type="html"><![CDATA[<h1 id="hibernate小结"><a href="#hibernate小结" class="headerlink" title="hibernate小结"></a>hibernate小结</h1><h2 id="hibernate概念"><a href="#hibernate概念" class="headerlink" title="hibernate概念"></a>hibernate概念</h2><blockquote><p>开放源代码的ORM框架</p></blockquote><blockquote><p>ORM: Object Relative Mapping</p></blockquote><blockquote><p>关键词: ORM 开源框架 持久层</p></blockquote><h2 id="hibernate的优势"><a href="#hibernate的优势" class="headerlink" title="hibernate的优势"></a>hibernate的优势</h2><ul><li>对JDBC访问数据库代码封装,提高我们写代码的效率</li><li>性能好,支持很多关系型数据库</li><li>功能扩展性好</li></ul><h2 id="hibernate的核心"><a href="#hibernate的核心" class="headerlink" title="hibernate的核心"></a>hibernate的核心</h2><ul><li>实体<blockquote><p>关于实体类的编写有一些约束,但是我们编写常规的POJO一般不会出错</p></blockquote></li><li>映射文件<blockquote><p>描述实体和表字段的映射关系 (一般写为（类名.hbm.xml）)</p></blockquote></li><li>hibernate核心配置文件<blockquote><p>hibernate底层代码默认加载src下的hibernate.cfg.xml</p></blockquote></li></ul><blockquote><p>一些hibernate的配置 核心配置(数据库链接,配置连接池) 方言配置 可选配置(打印sql语句,格式化sql语句) 映射文件加载配置</p></blockquote><h2 id="hibernate核心API"><a href="#hibernate核心API" class="headerlink" title="hibernate核心API"></a>hibernate核心API</h2><ul><li><p>configuration</p><blockquote><p>作用 加载配置文件,可以指定,可以加载默认<br>创建sessionFactory对象 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Configuration cfg = new Configuration();</span><br><span class="line">Configuration cfg = new Configuration().configure();</span><br><span class="line">SessionFactory sf = cfg.buildSeesionFactory();</span><br></pre></td></tr></table></figure></blockquote></li><li><p>SessionFactory</p><blockquote><p>session并不是轻量级的,一个应用所以不能频繁的创建和销毁SeesionFactory对象,一个应用应该尽量维护一个SessionFactory对象</p></blockquote></li><li><p>Session</p><blockquote><p>这里的session有别于servlet里的session对象,hibetnate中的session对象相当于数据库链接对象<br>可以利用session来操作数据库</p></blockquote></li></ul><h2 id="hibernate主键生成策略"><a href="#hibernate主键生成策略" class="headerlink" title="hibernate主键生成策略"></a>hibernate主键生成策略</h2><ul><li>自然主键 : 利用表中的字段做主键</li><li>代理主键 : 提供一个无业务意义的字段做主键<blockquote><p>主键生成策略指的是hibernate要以什么样的方式生成主键</p></blockquote></li><li>生成策略 increment identity senquence(orcal) native uuid assined</li></ul><h2 id="持久化类的三种状态"><a href="#持久化类的三种状态" class="headerlink" title="持久化类的三种状态"></a>持久化类的三种状态</h2><ul><li>瞬时态 没有唯一标识OID，没有被session管理</li><li>持久态 有唯一标识OID，已经被session管理 持久态对象可以自动更新数据库</li><li>托管态 有唯一标识OID，没有被session管理<blockquote><p>三种状态可以相互转换</p></blockquote></li></ul><h2 id="hibernate-一级缓存及快照区"><a href="#hibernate-一级缓存及快照区" class="headerlink" title="hibernate 一级缓存及快照区"></a>hibernate 一级缓存及快照区</h2><blockquote><p>一级缓存是hibetnate自带的,是session级别的,本质是session里维护的集合,查询的时候如果命中的一级缓存,直接从一级缓存返回,session关闭,缓存的数据也就没有了</p></blockquote><h2 id="其他API"><a href="#其他API" class="headerlink" title="其他API"></a>其他API</h2><ul><li>Query HQL 面向对象方式的查询。</li><li>Criteria QBC 完成面向对象化。</li><li>SQLQuery SQL查询</li></ul><h2 id="Hibernate的一对多"><a href="#Hibernate的一对多" class="headerlink" title="Hibernate的一对多"></a>Hibernate的一对多</h2><pre><code>◦ 表与表之间关系        ▪ 一对多关系        ▪ 多对多关系        ▪ 一对一关系◦ Hibernate的一对多配置        ▪ 搭建Hibernate基本环境        ▪ 创建表        ▪ 创建实体            • 一的一方                ◦ 放的是多的一方的集合            • 多的一方                ◦ 放的是一的一方的对象        ▪ 创建映射            • 一的一方                ◦ 配置的&lt;set&gt;集合            • 多的一方                ◦ 配置&lt;many-to-one&gt;        ▪ 编写测试类◦ Hibernate的一对多的操作        ▪ 级联操作：cascade，用于操作其关联的对象。            • 级联保存或更新            • 级联删除        ▪ 测试对象导航        ▪ 放弃外键维护权：inverse，用户控制是否有外键维护能力</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;hibernate小结&quot;&gt;&lt;a href=&quot;#hibernate小结&quot; class=&quot;headerlink&quot; title=&quot;hibernate小结&quot;&gt;&lt;/a&gt;hibernate小结&lt;/h1&gt;&lt;h2 id=&quot;hibernate概念&quot;&gt;&lt;a href=&quot;#hibern
      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结" scheme="http://yoursite.com/tag/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>通用代码抽取以及反射思想</title>
    <link href="http://yoursite.com/2018/08/21/%E9%80%9A%E7%94%A8%E4%BB%A3%E7%A0%81%E6%8A%BD%E5%8F%96%E4%BB%A5%E5%8F%8A%E5%8F%8D%E5%B0%84%E6%80%9D%E6%83%B3/"/>
    <id>http://yoursite.com/2018/08/21/通用代码抽取以及反射思想/</id>
    <published>2018-08-21T07:26:26.000Z</published>
    <updated>2018-08-28T11:28:12.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="通用DAO抽取"><a href="#通用DAO抽取" class="headerlink" title="通用DAO抽取"></a>通用DAO抽取</h2><p>&emsp;&emsp;在做项目的时候用到了抽取通用DAO，主要思想就是把一些通用的操作（增删改插分页等操作）抽取为一个接口，在用一个通用的实现类来实现这些基本的方法。那么在实现自己业务DAO的时候继承这个通用的实现类，达到复用的目地，那么我们只需关注自己核心的业务代码。</p><blockquote><p>抽取公共DAO及其实现<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="通用Sevlet抽取"><a href="#通用Sevlet抽取" class="headerlink" title="通用Sevlet抽取"></a>通用Sevlet抽取</h2><pre><code>&amp;emsp;&amp;emsp;暑期做项目的时候，我们一个servlet要完成多个功能，通常是前端传过来一个要完成的逻辑的参数，通常为呈现出以下复杂的if-else代码&gt; 反例 大量的分支语句控制程序流程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//查询用户的未读消息</span><br><span class="line">if(&quot;queryMessage&quot;.equals(flag)&amp;&amp;user!=null)&#123;                //ajax请求</span><br><span class="line">List&lt;Message&gt; messagesList = messageService.queryMessageByUserId(user.getId());</span><br><span class="line">JsonConfig jsonConfig = new JsonConfig();</span><br><span class="line">JSONArray jsonArray = JSONArray.fromObject(messagesList,jsonConfig);</span><br><span class="line">response.getWriter().println(jsonArray.toString());</span><br><span class="line">&#125;else if(&quot;readMessage&quot;.equals(flag))&#123;    //更新消息的状态</span><br><span class="line">int messageId = Integer.parseInt(request.getParameter(&quot;messageId&quot;));</span><br><span class="line">messageService.readMessage(messageId);</span><br><span class="line">&#125;else if (&quot;findDialogMessage&quot;.equals(flag)) &#123;</span><br><span class="line">int user_id = Integer.parseInt(request.getParameter(&quot;user_id&quot;));</span><br><span class="line">int other_person_id = Integer.parseInt(request.getParameter(&quot;other_person_id&quot;));</span><br><span class="line">List&lt;Message&gt; messageList = messageService.findDialogMessage(user_id,other_person_id);</span><br><span class="line">JsonConfig jsonConfig = new JsonConfig();</span><br><span class="line">JSONArray jsonArray = JSONArray.fromObject(messageList,jsonConfig);</span><br><span class="line">response.getWriter().println(jsonArray.toString());</span><br><span class="line">&#125;else if (&quot;queryAllMessage&quot;.equals(flag)&amp;&amp;user!=null) &#123;</span><br><span class="line">List&lt;Message&gt; messagesList = messageService.queryAllMessageByUserId(user.getId());</span><br><span class="line">JsonConfig jsonConfig = new JsonConfig();</span><br><span class="line">JSONArray jsonArray = JSONArray.fromObject(messagesList,jsonConfig);</span><br><span class="line">response.getWriter().println(jsonArray.toString());</span><br><span class="line">&#125;else if (&quot;deleteMessage&quot;.equals(flag)&amp;&amp;user!=null) &#123;</span><br></pre></td></tr></table></figure></code></pre><blockquote><p>思路 抽取一个基础的servlet,获取参数，反射出子类的方法，利用反射机制调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public class BaseServlet extends HttpServlet &#123;</span><br><span class="line">@Override</span><br><span class="line">public void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">// localhost:8080/store/productServlet?method=addProduct</span><br><span class="line">String method = req.getParameter(&quot;method&quot;);</span><br><span class="line"></span><br><span class="line">if (null == method || &quot;&quot;.equals(method) || method.trim().equals(&quot;&quot;)) &#123;</span><br><span class="line">method = &quot;execute&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 注意:此处的this代表的是子类的对象</span><br><span class="line">// System.out.println(this);</span><br><span class="line">// 子类对象字节码对象</span><br><span class="line">Class clazz = this.getClass();</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">// 查找子类对象对应的字节码中的名称为method的方法.这个方法的参数类型是:HttpServletRequest.class,HttpServletResponse.class</span><br><span class="line">Method md = clazz.getMethod(method, HttpServletRequest.class, HttpServletResponse.class);</span><br><span class="line">if(null!=md)&#123;</span><br><span class="line">String jspPath = (String) md.invoke(this, req, resp);</span><br><span class="line">if (null != jspPath) &#123;</span><br><span class="line">req.getRequestDispatcher(jspPath).forward(req, resp);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 默认方法</span><br><span class="line">public String execute(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>对上述反例代码的重构<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class MessageServlet extends BaseServlet &#123;</span><br><span class="line">private static final long serialVersionUID = 1L;</span><br><span class="line">MessageService messageService = new MessageServiceImpl();</span><br><span class="line">public String queryMessage(HttpServletRequest req, HttpServletResponse resp)&#123;</span><br><span class="line">//业务代码 返回要转发的请求的视图名称</span><br><span class="line">&#125;</span><br><span class="line">public String readMessage(HttpServletRequest req, HttpServletResponse resp)&#123;</span><br><span class="line">//业务代码 返回要转发的请求的视图名称</span><br><span class="line">&#125;</span><br><span class="line">public String findDialogMessage(HttpServletRequest req, HttpServletResponse resp)&#123;</span><br><span class="line">//业务代码 返回要转发的请求的视图名称</span><br><span class="line">&#125;</span><br><span class="line">public String queryAllMessage(HttpServletRequest req, HttpServletResponse resp)&#123;</span><br><span class="line">//业务代码 返回要转发的请求的视图名称</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>可以看到MessageServlet继承了我们抽取的BaseServlet，间接继承了HttpServlet，MesssageServlet不必重写doPost,doGet,service方法，更不必写获取业务逻辑参数的方法，在子类中，一个逻辑一个方法，实现了类似mvc框架的效果，逻辑十分清晰。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;通用DAO抽取&quot;&gt;&lt;a href=&quot;#通用DAO抽取&quot; class=&quot;headerlink&quot; title=&quot;通用DAO抽取&quot;&gt;&lt;/a&gt;通用DAO抽取&lt;/h2&gt;&lt;p&gt;&amp;emsp;&amp;emsp;在做项目的时候用到了抽取通用DAO，主要思想就是把一些通用的操作（增删改插分
      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
  </entry>
  
  <entry>
    <title>事务&amp;数据库连接池</title>
    <link href="http://yoursite.com/2018/08/19/%E4%BA%8B%E7%89%A9%E5%92%8C%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>http://yoursite.com/2018/08/19/事物和连接池/</id>
    <published>2018-08-19T10:33:39.000Z</published>
    <updated>2018-08-24T05:39:53.033Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务-amp-数据库连接池"><a href="#事务-amp-数据库连接池" class="headerlink" title="事务&amp;数据库连接池"></a>事务&amp;数据库连接池</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>Transaction  其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(回滚)</p></blockquote><ul><li>为什么要有事务?</li></ul><blockquote><p>为了确保逻辑的成功。 例子： 银行的转账。 </p></blockquote><h3 id="使用命令行方式演示事务。"><a href="#使用命令行方式演示事务。" class="headerlink" title="使用命令行方式演示事务。"></a>使用命令行方式演示事务。</h3><ul><li><p>开启事务</p><p>  start transaction;</p></li><li><p>提交或者回滚事务.</p><p>  commit; 提交事务， 数据将会写到磁盘上的数据库<br>  rollback ;  数据回滚，回到最初的状态。</p></li></ul><ol><li>关闭自动提交功能。</li></ol><p><img src="/img/img01.png" alt="icon"></p><ol start="2"><li>演示事务</li></ol><p><img src="/img/img02.png" alt="icon"></p><h3 id="使用代码方式演示事务"><a href="#使用代码方式演示事务" class="headerlink" title="使用代码方式演示事务"></a>使用代码方式演示事务</h3><blockquote><p>代码里面的事务，主要是针对连接来的。 </p><ol><li>通过conn.setAutoCommit（false ）来关闭自动提交的设置。</li></ol></blockquote><blockquote><ol start="2"><li>提交事务  conn.commit();</li></ol></blockquote><blockquote><ol start="3"><li>回滚事务 conn.rollback();</li></ol></blockquote><pre><code>@Testpublic void testTransaction(){    Connection conn = null;    PreparedStatement ps = null;    ResultSet rs = null;    try {        conn = JDBCUtil.getConn();        //连接，事务默认就是自动提交的。 关闭自动提交。        conn.setAutoCommit(false);        String sql = &quot;update account set money = money - ? where id = ?&quot;;        ps = conn.prepareStatement(sql);        //扣钱， 扣ID为1 的100块钱        ps.setInt(1, 100);        ps.setInt(2, 1);        ps.executeUpdate();        int a = 10 /0 ;        //加钱， 给ID为2 加100块钱        ps.setInt(1, -100);        ps.setInt(2, 2);        ps.executeUpdate();        //成功： 提交事务。        conn.commit();    } catch (SQLException e) {        try {            //事变： 回滚事务            conn.rollback();        } catch (SQLException e1) {            e1.printStackTrace();        }        e.printStackTrace();    }finally {        JDBCUtil.release(conn, ps, rs);    }}</code></pre><h3 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h3><ul><li>原子性</li></ul><blockquote><p>指的是 事务中包含的逻辑，不可分割。 </p></blockquote><ul><li>一致性</li></ul><blockquote><p>指的是 事务执行前后。数据完整性</p></blockquote><ul><li>隔离性</li></ul><blockquote><p>指的是 事务在执行期间不应该受到其他事务的影响</p></blockquote><ul><li>持久性</li></ul><blockquote><p>指的是 事务执行成功，那么数据应该持久保存到磁盘上。</p></blockquote><h3 id="事务的安全隐患"><a href="#事务的安全隐患" class="headerlink" title="事务的安全隐患"></a>事务的安全隐患</h3><blockquote><p>不考虑隔离级别设置，那么会出现以下问题。</p></blockquote><ul><li>读<blockquote><p>脏读 不可重读读  幻读.</p></blockquote></li></ul><pre><code>* 脏读&gt; 一个事务读到另外一个事务还未提交的数据* 不可重复读 &gt; 一个事务读到了另外一个事务提交的数据 ，造成了前后两次查询结果不一致。</code></pre><h4 id="读未提交-演示"><a href="#读未提交-演示" class="headerlink" title="读未提交 演示"></a>读未提交 演示</h4><ol><li><p>设置A窗口的隔离级别为 读未提交<br><img src="/img/img03.png" alt="icon"></p></li><li><p>两个窗口都分别开启事务</p></li></ol><p><img src="/img/img04.png" alt="icon"></p><ul><li>写</li></ul><blockquote><p>丢失更新</p></blockquote><h4 id="读已提交演示"><a href="#读已提交演示" class="headerlink" title="读已提交演示"></a>读已提交演示</h4><ol><li>设置A窗口的隔离级别为 读已提交</li></ol><p><img src="/img/img05.png" alt="icon"></p><ol start="2"><li>A B 两个窗口都开启事务， 在B窗口执行更新操作。</li></ol><p><img src="/img/img06.png" alt="icon"></p><ol start="3"><li>在A窗口执行的查询结果不一致。 一次是在B窗口提交事务之前，一次是在B窗口提交事务之后。</li></ol><p><img src="/img/img07.png" alt="icon"></p><blockquote><p>这个隔离级别能够屏蔽 脏读的现象， 但是引发了另一个问题  ，不可重复读。</p></blockquote><h3 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h3><blockquote><p>如果有一个连接的隔离级别设置为了串行化 ，那么谁先打开了事务， 谁就有了先执行的权利， 谁后打开事务，谁就只能得着，等前面的那个事务，提交或者回滚后，才能执行。  但是这种隔离级别一般比较少用。 容易造成性能上的问题。 效率比较低。</p></blockquote><ul><li>按效率划分，从高到低</li></ul><blockquote><p>读未提交  &gt; 读已提交  &gt; 可重复读  &gt; 可串行化</p></blockquote><ul><li>按拦截程度 ，从高到底</li></ul><blockquote><p>可串行化 &gt; 可重复读 &gt; 读已提交 &gt;  读未提交</p></blockquote><h2 id="事务总结"><a href="#事务总结" class="headerlink" title="事务总结"></a>事务总结</h2><h3 id="需要掌握的"><a href="#需要掌握的" class="headerlink" title="需要掌握的"></a>需要掌握的</h3><ol><li><p>在代码里面会使用事务 </p><pre><code>conn.setAutoCommit(false);</code></pre></li></ol><pre><code>conn.commit();conn.rollback();</code></pre><ol start="2"><li><p>事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。</p></li><li><p>事务是会自动提交的。 </p></li></ol><h3 id="需要了解的"><a href="#需要了解的" class="headerlink" title="需要了解的"></a>需要了解的</h3><h4 id="安全隐患"><a href="#安全隐患" class="headerlink" title="安全隐患"></a>安全隐患</h4><pre><code>读    脏读        一个事务读到了另一个事务未提交的数据    不可重复读        一个事务读到了另一个事务已提交的数据，造成前后两次查询结果不一致    幻读        一个事务读到了另一个事务insert的数据 ，造成前后查询结果不一致 。写    丢失更新。</code></pre><blockquote><p>   有关幻读问题 导致幻读的原始是因为开启了RR隔离级别,但RR的定义是别的事务不对本事务造成影响(哪怕是提交过后)这不是与可能导致的幻读现象矛盾?而教程也并未给出幻读的例子</p></blockquote><pre><code>(摘https://segmentfault.com/a/1190000012669504)由于很多人(当然也包括本人), 容易搞混 不可重复读 和 幻读, 这两者确实非常相似。但 不可重复读 主要是说多次读取一条记录, 发现该记录中某些列值被修改过。而 幻读 主要是说多次读取一个范围内的记录(包括直接查询所有记录结果或者做聚合统计), 发现结果不一致(标准档案一般指记录增多, 记录的减少应该也算是幻读)。(可以参考MySQL官方文档对 Phantom Rows 的介绍)其实对于 幻读, MySQL的InnoDB引擎默认的RR级别已经通过MVCC自动帮我们解决了, 所以该级别下, 你也模拟不出幻读的场景; 退回到 RC 隔离级别的话, 你又容易把幻读和不可重复读搞混淆, 所以这可能就是比较头痛的点吧!具体可以参考《高性能MySQL》对 RR 隔离级别的描述, 理论上RR级别是无法解决幻读的问题, 但是由于InnoDB引擎的RR级别还使用了MVCC, 所以也就避免了幻读的出现!</code></pre><h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><p>读未提交</p><blockquote><p>引发问题： 脏读 </p></blockquote><p>读已提交</p><blockquote><p>解决： 脏读 ， 引发： 不可重复读</p></blockquote><p>可重复读</p><blockquote><p>解决： 脏读 、 不可重复读 ， 未解决： 幻读</p></blockquote><p>可串行化</p><blockquote><p>解决： 脏读、 不可重复读 、 幻读。</p></blockquote><p>mySql 默认的隔离级别是 可重复读</p><p>Oracle 默认的隔离级别是  读已提交</p><h3 id="丢失更新"><a href="#丢失更新" class="headerlink" title="丢失更新"></a>丢失更新</h3><p><img src="/img/img08.png" alt="icon"></p><h3 id="解决丢失更新"><a href="#解决丢失更新" class="headerlink" title="解决丢失更新"></a>解决丢失更新</h3><ul><li>悲观锁</li></ul><blockquote><p>可以在查询的时候，加入 for update</p></blockquote><p><img src="/img/img09.png" alt="icon"></p><ul><li>乐观锁</li></ul><blockquote><p>要求程序员自己控制。 </p></blockquote><p><img src="/img/img10.png" alt="icon"></p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><blockquote><ol><li>数据库的连接对象创建工作，比较消耗性能。 </li></ol></blockquote><blockquote><p>2.一开始现在内存中开辟一块空间（集合） ， 一开先往池子里面放置 多个连接对象。  后面需要连接的话，直接从池子里面去。不要去自己创建连接了。  使用完毕， 要记得归还连接。确保连接对象能循环利用。</p></blockquote><p><img src="/img/img11.png" alt="icon"></p><h3 id="自定义数据库连接池"><a href="#自定义数据库连接池" class="headerlink" title="自定义数据库连接池"></a>自定义数据库连接池</h3><ul><li><p>代码实现</p></li><li><p>出现的问题：</p><ol><li><p>需要额外记住 addBack方法</p><ol start="2"><li><p>单例。</p></li><li><p>无法面向接口编程。 </p><p>UserDao dao = new UserDaoImpl();<br>dao.insert();</p></li></ol></li></ol></li></ul><pre><code>    DataSource dataSource = new MyDataSource();    因为接口里面没有定义addBack方法。 4. 怎么解决?   以addBack 为切入点。</code></pre><h3 id="解决自定义数据库连接池出现的问题。"><a href="#解决自定义数据库连接池出现的问题。" class="headerlink" title="解决自定义数据库连接池出现的问题。"></a>解决自定义数据库连接池出现的问题。</h3><blockquote><p>由于多了一个addBack 方法，所以使用这个连接池的地方，需要额外记住这个方法，并且还不能面向接口编程。</p></blockquote><blockquote><p>我们打算修改接口中的那个close方法。  原来的Connection对象的close方法，是真的关闭连接。<br>打算修改这个close方法，以后在调用close， 并不是真的关闭，而是归还连接对象。</p></blockquote><h3 id="如何扩展某一个方法"><a href="#如何扩展某一个方法" class="headerlink" title="如何扩展某一个方法?"></a>如何扩展某一个方法?</h3><blockquote><p>原有的方法逻辑，不是我们想要的。 想修改自己的逻辑</p></blockquote><ol><li><p>直接改源码  无法实现。</p></li><li><p>继承， 必须得知道这个接口的具体实现是谁。 </p></li><li><p>使用装饰者模式。 </p></li></ol><h2 id="开源连接池"><a href="#开源连接池" class="headerlink" title="开源连接池"></a>开源连接池</h2><h4 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h4><ol><li><p>导入jar文件</p></li><li><p>不使用配置文件：</p></li></ol><pre><code>public void testDBCP01(){    Connection conn = null;    PreparedStatement ps = null;    try {        //1. 构建数据源对象        BasicDataSource dataSource = new BasicDataSource();        //连的是什么类型的数据库， 访问的是哪个数据库 ， 用户名， 密码。。        //jdbc:mysql://localhost/bank 主协议：子协议 ://本地/数据库        dataSource.setDriverClassName(&quot;com.mysql.jdbc.Driver&quot;);        dataSource.setUrl(&quot;jdbc:mysql://localhost/bank&quot;);        dataSource.setUsername(&quot;root&quot;);        dataSource.setPassword(&quot;root&quot;);        //2. 得到连接对象        conn = dataSource.getConnection();        String sql = &quot;insert into account values(null , ? , ?)&quot;;        ps = conn.prepareStatement(sql);        ps.setString(1, &quot;admin&quot;);        ps.setInt(2, 1000);        ps.executeUpdate();    } catch (SQLException e) {        e.printStackTrace();    }finally {        JDBCUtil.release(conn, ps);    }}</code></pre><ol start="2"><li>使用配置文件方式：</li></ol><pre><code>Connection conn = null;PreparedStatement ps = null;try {    BasicDataSourceFactory factory = new BasicDataSourceFactory();    Properties properties = new Properties();    InputStream is = new FileInputStream(&quot;src//dbcpconfig.properties&quot;);    properties.load(is);    DataSource dataSource = factory.createDataSource(properties);    //2. 得到连接对象    conn = dataSource.getConnection();    String sql = &quot;insert into account values(null , ? , ?)&quot;;    ps = conn.prepareStatement(sql);    ps.setString(1, &quot;liangchaowei&quot;);    ps.setInt(2, 100);    ps.executeUpdate();} catch (Exception e) {    e.printStackTrace();}finally {    JDBCUtil.release(conn, ps);}</code></pre><ul><li>C3P0</li></ul><blockquote><p>拷贝jar文件 到 lib目录</p></blockquote><h3 id="不使用配置文件方式"><a href="#不使用配置文件方式" class="headerlink" title="不使用配置文件方式"></a>不使用配置文件方式</h3><pre><code>Connection conn = null;PreparedStatement ps = null;try {    //1. 创建datasource    ComboPooledDataSource dataSource = new ComboPooledDataSource();    //2. 设置连接数据的信息    dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);    //忘记了---&gt; 去以前的代码 ---&gt; jdbc的文档    dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost/bank&quot;);    dataSource.setUser(&quot;root&quot;);    dataSource.setPassword(&quot;root&quot;);    //2. 得到连接对象    conn = dataSource.getConnection();    String sql = &quot;insert into account values(null , ? , ?)&quot;;    ps = conn.prepareStatement(sql);    ps.setString(1, &quot;admi234n&quot;);    ps.setInt(2, 103200);    ps.executeUpdate();} catch (Exception e) {    e.printStackTrace();}finally {    JDBCUtil.release(conn, ps);}</code></pre><h3 id="使用配置文件方式"><a href="#使用配置文件方式" class="headerlink" title="使用配置文件方式"></a>使用配置文件方式</h3><pre><code>//默认会找 xml 中的 default-config 分支。 ComboPooledDataSource dataSource = new ComboPooledDataSource();//2. 设置连接数据的信息dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;);//忘记了---&gt; 去以前的代码 ---&gt; jdbc的文档dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost/bank&quot;);dataSource.setUser(&quot;root&quot;);dataSource.setPassword(&quot;root&quot;);//2. 得到连接对象conn = dataSource.getConnection();String sql = &quot;insert into account values(null , ? , ?)&quot;;ps = conn.prepareStatement(sql);ps.setString(1, &quot;admi234n&quot;);ps.setInt(2, 103200);</code></pre><h2 id="DBUtils"><a href="#DBUtils" class="headerlink" title="DBUtils"></a>DBUtils</h2><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><pre><code>        //dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作。 不在他的考虑范围QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());//增加//queryRunner.update(&quot;insert into account values (null , ? , ? )&quot;, &quot;aa&quot; ,1000);//删除//queryRunner.update(&quot;delete from account where id = ?&quot;, 5);//更新//queryRunner.update(&quot;update account set money = ? where id = ?&quot;, 10000000 , 6);</code></pre><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><ol><li>直接new接口的匿名实现类</li></ol><pre><code>QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());Account  account =  queryRunner.query(&quot;select * from account where id = ?&quot;, new ResultSetHandler&lt;Account&gt;(){    @Override    public Account handle(ResultSet rs) throws SQLException {        Account account  =  new Account();        while(rs.next()){            String name = rs.getString(&quot;name&quot;);            int money = rs.getInt(&quot;money&quot;);            account.setName(name);            account.setMoney(money);        }        return account;    } }, 6);System.out.println(account.toString());</code></pre><ol start="2"><li>直接使用框架已经写好的实现类。</li></ol><pre><code>* 查询单个对象    QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());    //查询单个对象    Account account = queryRunner.query(&quot;select * from account where id = ?&quot;,             new BeanHandler&lt;Account&gt;(Account.class), 8);* 查询多个对象    QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());    List&lt;Account&gt; list = queryRunner.query(&quot;select * from account &quot;,            new BeanListHandler&lt;Account&gt;(Account.class));</code></pre><h3 id="ResultSetHandler-常用的实现类"><a href="#ResultSetHandler-常用的实现类" class="headerlink" title="ResultSetHandler 常用的实现类"></a>ResultSetHandler 常用的实现类</h3><p>以下两个是使用频率最高的</p><pre><code>BeanHandler,  查询到的单个数据封装成一个对象BeanListHandler, 查询到的多个数据封装 成一个List&lt;对象&gt;</code></pre><hr><pre><code>ArrayHandler,  查询到的单个数据封装成一个数组ArrayListHandler,  查询到的多个数据封装成一个集合 ，集合里面的元素是数组。 MapHandler,  查询到的单个数据封装成一个mapMapListHandler,查询到的多个数据封装成一个集合 ，集合里面的元素是map。 </code></pre><p>ColumnListHandler<br>KeyedHandler<br>ScalarHandler</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h2><pre><code>使用命令行演示使用代码演示</code></pre><p>脏读、</p><p>不可重复读、</p><p>幻读<br>丢失更新</p><pre><code>悲观锁乐观锁4个隔离级别    读未提交    读已提交    可重复读    可串行化</code></pre><h2 id="数据连接池"><a href="#数据连接池" class="headerlink" title="数据连接池"></a>数据连接池</h2><ul><li><p>DBCP</p><p>  不使用配置</p><p>  使用配置</p></li><li><p>C3P0</p><p>  不使用配置</p><p>  使用配置 （必须掌握）</p></li><li><p>自定义连接池 </p><p>  装饰者模式</p></li></ul><h2 id="DBUtils-1"><a href="#DBUtils-1" class="headerlink" title="DBUtils"></a>DBUtils</h2><blockquote><p>简化了我们的CRUD ， 里面定义了通用的CRUD方法。 </p></blockquote><pre><code>queryRunner.update();queryRunner.query</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;事务-amp-数据库连接池&quot;&gt;&lt;a href=&quot;#事务-amp-数据库连接池&quot; class=&quot;headerlink&quot; title=&quot;事务&amp;amp;数据库连接池&quot;&gt;&lt;/a&gt;事务&amp;amp;数据库连接池&lt;/h1&gt;&lt;h2 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; cla
      
    
    </summary>
    
      <category term="转载" scheme="http://yoursite.com/categories/%E8%BD%AC%E8%BD%BD/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tag/%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>7月</title>
    <link href="http://yoursite.com/2018/07/21/7%E6%9C%88/"/>
    <id>http://yoursite.com/2018/07/21/7月/</id>
    <published>2018-07-21T01:05:12.000Z</published>
    <updated>2019-03-24T05:34:48.032Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;上个月的突发事件，到现在已经一个多月了。说实话，事情刚发生的时候，有种天塌的感觉，生活节奏完全被打乱了。不过还好，现在又进入我的计划之中。暑假前半截培训告一段落，现在可以停下来，output一点什么了。罗老师的给我的印象很深刻，不过我却没有怎么听她将有关英语的知识。不是不尊重她，也不是不学英语了。我把英语当作是我一生要学习的语言，集中几天来强化某一项技能，这是令我最反感的。我最喜欢罗倩老师输出她的观点，输入她的想法的时候，正如她所说，我的评论能力，说出自己核心观点的能力是不够的。对于一些事情，能够去欣赏，但如果要让我说点什么，除了，‘好’，‘厉害’，‘很棒’这些笼统的词汇，也再想不起什么了。</p><ul><li><h2 id="有关学习"><a href="#有关学习" class="headerlink" title="有关学习"></a>有关学习</h2>&emsp;&emsp;大二下半学期，参加了服创外包大赛，我发现通过这种方式，掌握的技能明显更扎实，时间也过的飞快。虽然没能拿奖，经过了整个比赛的流程，对自己能力的提升也十分的大。通过这次比赛，了解了hadoop，hive等大数据平台的概念和知识，我对这个方向也比较感兴趣。先把java开发的路线走一边，可在回过头来再了解这些知识。然后下半学期就是啃了计算机系统基础这本书，现在让我总结不出个什么名堂来，但是心中对于计算机底层的那种感觉，是很敞亮的，不再是以前那种混沌了，我想这就是达到效果了。</li><li><h2 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h2>&emsp;&emsp;必须更好的释放自己的压力，回去折腾了这么久，产生的情绪已经影响到我的睡眠了，要是有个地方能让我暴力输入一下就好了。父亲的离开让我对亲情淡漠了十几年，母亲这次生病唤醒了我心中的那份亲情，我知道我其实不是一个亲情淡漠的人。得知消息的那一天，真的是慌了，我以为母亲以后会永远像个孩子在我身边。母亲最终还是把那个结打开了，回到学校，我必须努力的成长，我知道，母亲的精神支柱，是我</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;上个月的突发事件，到现在已经一个多月了。说实话，事情刚发生的时候，有种天塌的感觉，生活节奏完全被打乱了。不过还好，现在又进入我的计划之中。暑假前半截培训告一段落，现在可以停下来，output一点什么了。罗老师的给我的印象很深刻，不过我却没有怎么听她将
      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结 规划" scheme="http://yoursite.com/tag/%E6%80%BB%E7%BB%93-%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>通用链表结构设计</title>
    <link href="http://yoursite.com/2018/06/04/%E9%80%9A%E7%94%A8%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/06/04/通用链表结构设计/</id>
    <published>2018-06-04T11:13:40.000Z</published>
    <updated>2018-06-04T14:46:17.719Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define INIT_SIZE 50   //初始大小</span><br><span class="line">#define INCREMENT 10   //增量</span><br><span class="line">typedef int  Status;</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define OK 1</span><br><span class="line">typedef struct SeqList&#123;</span><br><span class="line">void *elem;</span><br><span class="line">int size;      //元素字节数</span><br><span class="line">int length;    //当前元素个数</span><br><span class="line">int listsize;  //分配的元素容量</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//list： 顺序表的地址   size：元素字节数</span><br><span class="line">void InitList(SeqList *list, int size)&#123;</span><br><span class="line">list-&gt;elem = malloc(size*INIT_SIZE);</span><br><span class="line">if(!list-&gt;elem)&#123;</span><br><span class="line">exit(-2);</span><br><span class="line">&#125;</span><br><span class="line">list-&gt;listsize = INIT_SIZE;</span><br><span class="line">list-&gt;length = 0;</span><br><span class="line">list-&gt;size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//销毁线性表</span><br><span class="line">void DestoryList(SeqList *list)&#123;</span><br><span class="line">if(list!=NULL)&#123;</span><br><span class="line">free(list-&gt;elem);</span><br><span class="line">list-&gt;elem = NULL;</span><br><span class="line">&#125;</span><br><span class="line">list = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空线性表</span><br><span class="line">void ListEmpty(SeqList *list)&#123;</span><br><span class="line">if(list!=NULL)&#123;</span><br><span class="line">list-&gt;length = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回当前元素个数</span><br><span class="line">int ListLength(SeqList list)&#123;</span><br><span class="line">return list.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回第i个元素的值</span><br><span class="line">void GetElem(SeqList list, int i, void *e)&#123;</span><br><span class="line">int k = 1;</span><br><span class="line">e = (char*)(list.elem)+(i-1)*list.size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在第i个元素之前插入</span><br><span class="line">//list：线性表地址    i：第i个元素   e：要插入的值的地址</span><br><span class="line">Status ListInsert(SeqList *list, int i, void *e)&#123;</span><br><span class="line">int k = 0;</span><br><span class="line">void *p;</span><br><span class="line">void *q;</span><br><span class="line">if(i &lt;=0 &amp;&amp; i &gt; list-&gt;length+1)&#123;</span><br><span class="line">return ERROR;</span><br><span class="line">&#125;</span><br><span class="line">if(list-&gt;length==list-&gt;listsize)&#123;</span><br><span class="line">list-&gt;elem = realloc(list-&gt;elem, (list-&gt;listsize+INCREMENT)*list-&gt;size);   //重新分配元素</span><br><span class="line">if(!list-&gt;elem)&#123;exit(-2);&#125;</span><br><span class="line">list-&gt;listsize+=INCREMENT;</span><br><span class="line">&#125;</span><br><span class="line">q = (char*)list-&gt;elem+list-&gt;size*(i-1);   //要插入元素位置</span><br><span class="line">for(p = (char*)list-&gt;elem+list-&gt;size*(list-&gt;length-1); p&gt;=q; p=(char*)p-list-&gt;size)&#123;</span><br><span class="line">memcpy((char*)p+list-&gt;size, p, list-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line">memcpy(q, e, list-&gt;size);</span><br><span class="line">list-&gt;length++;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//删除第i个元素</span><br><span class="line">Status ListDelete(SeqList *list, int i)&#123;</span><br><span class="line">void *p, *q;</span><br><span class="line">if(i&lt;=0&amp;&amp;i&gt;list-&gt;length)&#123;</span><br><span class="line">return ERROR;</span><br><span class="line">&#125;</span><br><span class="line">q = (char*)list-&gt;elem+(i-1)*list-&gt;size;//被删除元素的位置</span><br><span class="line">p = (char*)list-&gt;elem+(list-&gt;length-1)*list-&gt;size;   //表尾位置</span><br><span class="line">for(q = (char*)q+list-&gt;size; q&lt;=p; q = (char*)q+list-&gt;size)&#123;</span><br><span class="line">memcpy((char*)q-list-&gt;size,q,list-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line">list-&gt;length--;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回第一个满足compare的位置</span><br><span class="line">void LocateElem(SeqList list, void *find, int(*compare)(void*, void*))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//自定义遍历方法</span><br><span class="line">void Travel_Int(SeqList list)&#123;</span><br><span class="line">int k = 0;</span><br><span class="line">while(k&lt;list.listsize)&#123;</span><br><span class="line">void *ak = (char*)list.elem+k*list.size;</span><br><span class="line">printf(&quot;%d\n&quot;, *(int*)ak);</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">SeqList list;</span><br><span class="line">InitList(&amp;list, sizeof(int));</span><br><span class="line">for(i = 50; i&gt;0; i--)&#123;</span><br><span class="line">ListInsert(&amp;list, 1, &amp;i);</span><br><span class="line">&#125;</span><br><span class="line">ListDelete(&amp;list, 2);</span><br><span class="line">Travel_Int(list);</span><br><span class="line">DestoryList(&amp;list);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="程序设计范式" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/"/>
    
    
      <category term="数据结构 c语言" scheme="http://yoursite.com/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>通用顺序表结构设计</title>
    <link href="http://yoursite.com/2018/06/04/%E9%80%9A%E7%94%A8%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/06/04/通用顺序表结构设计/</id>
    <published>2018-06-04T11:13:40.000Z</published>
    <updated>2018-06-04T15:11:28.881Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;结合本学期所学思想，有时间会去实现一些常见的数据结构和算法，就把它作为结课项目了。大一学习了数据结构和算法这门课，很多的细节都已经忘记了，大致的思想还是存在的，很多地方翻一翻书，理解的也很快，实现起来也并不难。设计了这么多通用性的东西，其实它的关键点在与理解内存的布局，只要抓住了这个核心，就能很好的举一反三了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define INIT_SIZE 50   //初始大小</span><br><span class="line">#define INCREMENT 10   //增量</span><br><span class="line">typedef int  Status;</span><br><span class="line">#define ERROR 0</span><br><span class="line">#define OK 1</span><br><span class="line">typedef struct SeqList&#123;</span><br><span class="line">void *elem;</span><br><span class="line">int size;      //元素字节数</span><br><span class="line">int length;    //当前元素个数</span><br><span class="line">int listsize;  //分配的元素容量</span><br><span class="line">&#125;SeqList;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//list：顺序表的地址   size：元素字节数</span><br><span class="line">void InitList(SeqList *list, int size)&#123;</span><br><span class="line">list-&gt;elem = malloc(size*INIT_SIZE);</span><br><span class="line">if(!list-&gt;elem)&#123;</span><br><span class="line">exit(-2);</span><br><span class="line">&#125;</span><br><span class="line">list-&gt;listsize = INIT_SIZE;</span><br><span class="line">list-&gt;length = 0;</span><br><span class="line">list-&gt;size = size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//销毁线性表</span><br><span class="line">void DestoryList(SeqList *list)&#123;</span><br><span class="line">if(list!=NULL)&#123;</span><br><span class="line">free(list-&gt;elem);</span><br><span class="line">list-&gt;elem = NULL;</span><br><span class="line">&#125;</span><br><span class="line">list = NULL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//清空线性表</span><br><span class="line">void ListEmpty(SeqList *list)&#123;</span><br><span class="line">if(list!=NULL)&#123;</span><br><span class="line">list-&gt;length = 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回当前元素个数</span><br><span class="line">int ListLength(SeqList list)&#123;</span><br><span class="line">return list.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回第i个元素的值</span><br><span class="line">void GetElem(SeqList list, int i, void *e)&#123;</span><br><span class="line">int k = 1;</span><br><span class="line">e = (char*)(list.elem)+(i-1)*list.size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//在第i个元素之前插入</span><br><span class="line">//list：线性表地址    i：第i个元素   e：要插入的值的地址</span><br><span class="line">Status ListInsert(SeqList *list, int i, void *e)&#123;</span><br><span class="line">int k = 0;</span><br><span class="line">void *p;</span><br><span class="line">void *q;</span><br><span class="line">if(i &lt;=0 &amp;&amp; i &gt; list-&gt;length+1)&#123;</span><br><span class="line">return ERROR;</span><br><span class="line">&#125;</span><br><span class="line">if(list-&gt;length==list-&gt;listsize)&#123;</span><br><span class="line">list-&gt;elem = realloc(list-&gt;elem, (list-&gt;listsize+INCREMENT)*list-&gt;size);   //重新分配元素</span><br><span class="line">if(!list-&gt;elem)&#123;exit(-2);&#125;</span><br><span class="line">list-&gt;listsize+=INCREMENT;</span><br><span class="line">&#125;</span><br><span class="line">q = (char*)list-&gt;elem+list-&gt;size*(i-1);   //要插入元素位置</span><br><span class="line">for(p = (char*)list-&gt;elem+list-&gt;size*(list-&gt;length-1); p&gt;=q; p=(char*)p-list-&gt;size)&#123;</span><br><span class="line">memcpy((char*)p+list-&gt;size, p, list-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line">memcpy(q, e, list-&gt;size);</span><br><span class="line">list-&gt;length++;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//删除第i个元素</span><br><span class="line">Status ListDelete(SeqList *list, int i)&#123;</span><br><span class="line">void *p, *q;</span><br><span class="line">if(i&lt;=0&amp;&amp;i&gt;list-&gt;length)&#123;</span><br><span class="line">return ERROR;</span><br><span class="line">&#125;</span><br><span class="line">q = (char*)list-&gt;elem+(i-1)*list-&gt;size;//被删除元素的位置</span><br><span class="line">p = (char*)list-&gt;elem+(list-&gt;length-1)*list-&gt;size;   //表尾位置</span><br><span class="line">for(q = (char*)q+list-&gt;size; q&lt;=p; q = (char*)q+list-&gt;size)&#123;</span><br><span class="line">memcpy((char*)q-list-&gt;size,q,list-&gt;size);</span><br><span class="line">&#125;</span><br><span class="line">list-&gt;length--;</span><br><span class="line">return OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回第一个满足compare的位置</span><br><span class="line">void LocateElem(SeqList list, void *find, int(*compare)(void*, void*))&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//自定义遍历方法</span><br><span class="line">void Travel_Int(SeqList list)&#123;</span><br><span class="line">int k = 0;</span><br><span class="line">while(k&lt;list.listsize)&#123;</span><br><span class="line">void *ak = (char*)list.elem+k*list.size;</span><br><span class="line">printf(&quot;%d\n&quot;, *(int*)ak);</span><br><span class="line">k++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//test</span><br><span class="line">int main()&#123;</span><br><span class="line">int i = 0;</span><br><span class="line">SeqList list;</span><br><span class="line">InitList(&amp;list, sizeof(int));</span><br><span class="line">for(i = 50; i&gt;0; i--)&#123;</span><br><span class="line">ListInsert(&amp;list, 1, &amp;i);</span><br><span class="line">&#125;</span><br><span class="line">ListDelete(&amp;list, 2);</span><br><span class="line">Travel_Int(list);</span><br><span class="line">DestoryList(&amp;list);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还是c写着舒服啊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;结合本学期所学思想，有时间会去实现一些常见的数据结构和算法，就把它作为结课项目了。大一学习了数据结构和算法这门课，很多的细节都已经忘记了，大致的思想还是存在的，很多地方翻一翻书，理解的也很快，实现起来也并不难。设计了这么多通用性的东西，其实它的关键点
      
    
    </summary>
    
      <category term="程序设计范式" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/"/>
    
    
      <category term="数据结构 c语言" scheme="http://yoursite.com/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>搬家</title>
    <link href="http://yoursite.com/2018/06/02/%E6%90%AC%E5%AE%B6/"/>
    <id>http://yoursite.com/2018/06/02/搬家/</id>
    <published>2018-06-02T10:29:19.000Z</published>
    <updated>2018-06-02T11:03:17.080Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;花了一天时间把学习环境转移到Ubuntu,不为别的，仅仅像换个发型和桌面一样，换个心情。<br>&emsp;&emsp;这两天把朋友圈和qq空间都关了，对于这两大毒瘤，我还是逃避来的更好。一直相信，我只是习惯了有这一套动作序列而已，看了qq空间看朋友圈，看了朋友圈再看qq空间，一连翻到别人好几天前的动态，每天非得把时间刷满似的。它应该是可以从我生活中抹去的，纯粹浪费时间而已，我并未从中收获到什么，除了一些别人的情绪。多关注自己岂不是更好。专家说我们养成一个习惯需要21天，这一点我的体会很深，强迫自己叠了20多天被子，现在已经坚持一年多了吧。同理，我们戒掉一个习惯也许也只要21天吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;花了一天时间把学习环境转移到Ubuntu,不为别的，仅仅像换个发型和桌面一样，换个心情。&lt;br&gt;&amp;emsp;&amp;emsp;这两天把朋友圈和qq空间都关了，对于这两大毒瘤，我还是逃避来的更好。一直相信，我只是习惯了有这一套动作序列而已，看了qq空间看朋友
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>五月总结</title>
    <link href="http://yoursite.com/2018/05/31/%E4%BA%94%E6%9C%88%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/31/五月总结/</id>
    <published>2018-05-31T03:31:40.000Z</published>
    <updated>2018-08-26T01:42:17.165Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;五月份，大概看了一下软件工程原理，月底了，来梳理一下知识点。</p><ul><li><h2 id="软件开发方法"><a href="#软件开发方法" class="headerlink" title="软件开发方法"></a>软件开发方法</h2>说明：和程序设计范式的内容有些重叠，我的理解就是程序范式是代码级别的，这里的软件开发方法是思想级别的<ul><li>结构化方法<ul><li>结构化分析 使用数据流图完成需求分析工作</li><li>结构化设计</li><li>结构化程序设计</li><li>优缺点：适合数据处理领域的问题，但不适合大规模的、特别复杂、需求常变化的项目。</li></ul></li><li>面向对象<ul><li>面向对象分析</li><li>面向对象设计</li><li>面向对象程序设计</li><li>优缺点：人易于理解</li></ul></li><li>jackson方法<ul><li>JSP方法<br>以数据结构为驱动，适合小项目</li><li>JSD方法<br>JSP方法的扩充，是一种基于进程的开发方法，适用于时许特点较强的系统，包括数据处理系统和一些实时控制系统。    </li><li>原型方法<br>它的目的是迅速的开发一个用户看的见，能感受到的系统。适用于用户需求不清，需求经常变化的情况，也是适用于系统不大也不复杂的情形。（怎么又有原型方法有有原型模型呢）</li></ul></li><li>敏捷开发 有一个敏捷宣言。。。它是敏捷开发的理念<ul><li>极限编程<br>  4大价值观、5个原则、12个最佳实践</li><li>水晶法<br>  水晶法认为每一个不同的项目需要不同的策略。        </li><li>并列整求法<br>  使用迭代的方法，每30天一次的迭代称为一个冲刺，小组并行实现产品，通过简短的日常会以协调</li><li>自适应软件开发<br>  6个基本的原则</li></ul></li></ul></li><li><h2 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h2><ul><li>能力成熟度模型CMM<br>  用于评价一个开发团队的软件开发能力，有5个级别</li><li>能力成熟度模型改进CMMI<ul><li>阶段式模型</li><li>连续式模型</li></ul></li><li>统一过程</li></ul></li><li><h2 id="软件过程模型"><a href="#软件过程模型" class="headerlink" title="软件过程模型"></a>软件过程模型</h2>理解：软件开发方法和软件过程模型的关系就是，一个过程模型可以选择不同的开法方法来开发。<ul><li>瀑布模型<br>适用场景：适合于需求很明确的项目，他的过程分为需求分析，概要和详细设计，编码，测试，运行与维护，前一个步骤完成了才继续完成下一个步骤<br>优点：易于理解，管理成本低<br>缺点：当需求发生变化时，对项目的影响很大，项目的错误往往到了后期才会体现，从而导致项目延期或者项目的失败。<br>变型：V模型，特点是比瀑布模型更加重视测试计划，一旦编码完成，立刻进行单元测试，集成测试等。</li><li>增量模型<br>适用场景：需求不明确的项目<br>优点：完成了一个模块的开发，立即交付客户，这样可以减小承担的风险<br>缺点：管理模块有一定难度，初始增量很重要，早起的需求思考必须严谨，它像地基一样</li><li>原型模型<br>说明：在早期需求不明确时，先开发一个简易的可运行的系统，先看是否满足客户需求<br>适用场景：需求不明确<br>优点：可以很好地适应需求的变化<br>缺点：原型设计有一定难度，可能和客户存在一定的交流问题</li><li>螺旋模型<br>说明: 螺旋模型强调风险分析，它是一个迭代的模型，意思就是说重复地干着这这几件事情：制定计划，风险分析，实施工程，用户评估。当然每次一迭代意味着项目进入了下一里程碑。<br>优点: 适合风险较大的项目，同时也能很好地应对客户需求的变化<br>缺点: 过多的迭代增加成本，需要开发人员具有相当的风险评估知识</li><li>喷泉模型<br>适用场景：适用与面向对象的开发方法<br>优点：它允许开发过程中的各种活动（分析，设计，实现，维护，演化）交叉、迭代地进行。各种活动没有明确的界限，增加了开发的效率<br>缺点：由于各个开发阶段是重叠的，就不利于项目的管理。</li><li>基于构件的开发模型<br>说明：它的思想就是重用<br>优点：它直接在事先建立的构件库里找构件，能用直接加到项目，不能用就修改源码，开发效率极快<br>缺点：还不晓得有啥子缺点</li><li>形式化方法模型<br>它是建立在严格数学基础之上的软件开发方法。用严格的数学语言描述功能和设计；</li></ul></li><li><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2>  范围：分为人员管理、产品管理、过程管理、项目管理<ul><li>成本估算方法<ul><li>自顶向下</li><li>自底向上</li><li>差别估算</li><li>COCOMO模型</li><li>COCOMOII模型</li><li>Putnam模型</li></ul></li><li>进度管理</li><li>质量管理</li><li>配置管理</li></ul></li><li><h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2>  1</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;五月份，大概看了一下软件工程原理，月底了，来梳理一下知识点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;h2 id=&quot;软件开发方法&quot;&gt;&lt;a href=&quot;#软件开发方法&quot; class=&quot;headerlink&quot; title=&quot;软件开发方法&quot;&gt;&lt;/a&gt;软件开发方法&lt;/h
      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结 规划" scheme="http://yoursite.com/tag/%E6%80%BB%E7%BB%93-%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>处理自己的失误</title>
    <link href="http://yoursite.com/2018/05/25/%E5%A4%84%E7%90%86%E8%87%AA%E5%B7%B1%E7%9A%84%E5%A4%B1%E8%AF%AF/"/>
    <id>http://yoursite.com/2018/05/25/处理自己的失误/</id>
    <published>2018-05-25T11:26:54.000Z</published>
    <updated>2018-06-04T22:13:34.987Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;避免给自己太多的消极暗示，要学会与烦恼相处共存，而不是一定视其如仇宼，可以留给自己沮丧的一小段时间</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;避免给自己太多的消极暗示，要学会与烦恼相处共存，而不是一定视其如仇宼，可以留给自己沮丧的一小段时间&lt;/p&gt;

      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>实验：程序的机器级实现</title>
    <link href="http://yoursite.com/2018/05/21/%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%BA%E5%99%A8%E7%BA%A7%E5%AE%9E%E7%8E%B0%E5%AE%9E%E9%AA%8C/"/>
    <id>http://yoursite.com/2018/05/21/程序的机器级实现实验/</id>
    <published>2018-05-21T02:40:34.000Z</published>
    <updated>2018-05-25T11:26:03.663Z</updated>
    
    <content type="html"><![CDATA[<p>一、实验目的<br>通过各种变量赋值的的汇编实现、函数调用的汇编实现以及栈中对应的具体活动，从汇编语言角度理解C/C++机理以及相关代码是怎样被编译成汇编代码的。<br>二、实验环境<br>微机，配置Windows操作系统、GCC、LC3等工具。<br>三、实验内容<br>计算机系统结构和汇编语言的知识；寄存器知识和汇编语言的一些指令。<br>四、实验过程<br>1、gcc反汇编执行<br>（1）变量赋值与类型转换<br>C语言代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">int i;</span><br><span class="line">short s1;</span><br><span class="line">short s2;</span><br><span class="line">i = 108;</span><br><span class="line">s1 = i;</span><br><span class="line">s2 = s1+1;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>汇编指令（gcc编译）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">movl%eax, -12(%ebp)</span><br><span class="line">movl-12(%ebp), %eax</span><br><span class="line">call__alloca</span><br><span class="line">call___main</span><br><span class="line">movl$108, -4(%ebp)</span><br><span class="line">movl-4(%ebp), %eax</span><br><span class="line">movw%ax, -6(%ebp)</span><br><span class="line">movzwl-6(%ebp), %eax</span><br><span class="line">incl%eax</span><br><span class="line">movw%ax, -8(%ebp)</span><br><span class="line">movl$0, %eax</span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure></p><p>分析：我们可以看到gcc在对int变量i赋值的时候用的是movl指令，指令后缀l的的含义是双字，基址的选择是栈底指针，与老师书上有出入，但并没有关系，他们都能访问到我们栈中分配的变量<br>在short转int型的时候编译器巧妙地吧eax的低16位即ax寄存器中的址放入了变量s1中<br>（2）数组变量赋初值<br>C语言代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">int a[4];</span><br><span class="line">for( int i = 0; i&lt;4; i++)&#123;</span><br><span class="line">a[i]=0;</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>汇编代码(vc反汇编的)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">                int a[4];</span><br><span class="line">                int i;</span><br><span class="line">                for(i = 0; i&lt;4; i++)&#123;</span><br><span class="line">00401028   mov         dword ptr [ebp-14h],0</span><br><span class="line">0040102F   jmp         main+2Ah (0040103a)</span><br><span class="line">00401031   mov         eax,dword ptr [ebp-14h]</span><br><span class="line">00401034   add         eax,1</span><br><span class="line">00401037   mov         dword ptr [ebp-14h],eax</span><br><span class="line">0040103A   cmp         dword ptr [ebp-14h],4</span><br><span class="line">0040103E   jge         main+3Dh (0040104d)</span><br><span class="line">                    a[i]=0;</span><br><span class="line">00401040   mov         ecx,dword ptr [ebp-14h]</span><br><span class="line">00401043   mov         dword ptr [ebp+ecx*4-10h],0</span><br><span class="line">                &#125;</span><br><span class="line">0040104B   jmp         main+21h (00401031)</span><br><span class="line">                return 0;</span><br><span class="line">0040104D   xor         eax,eax</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>分析：<br><img src="/img/pc1.png" alt="“”"><br>我们可以看到编译器把i变量从栈中取到了寄存器eax中，每次加1后又送回了栈中。对于a[i]=0,这一条语句，编译器把它翻译成了两条汇编语句：<br>mov ecx,dword ptr [ebp-14h]  我们知道cpu的存储器寻址方式有： 基地址+比例变址+偏移量，此处就是为了计算比例变址而做准备的。<br>mov    dword ptr [ebp+ecx*4-10h],0  上面一条语句把i的值又从栈中取出来放到了寄存器ecx中，从而可以通过栈底指针计算到a[i]的地址，并为其赋初值</p><p>（3）递归调用<br>C语言代码（递归求和）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int recur_sum(int n)&#123;</span><br><span class="line">int result;</span><br><span class="line">if(n &lt;= 0)&#123;</span><br><span class="line">result=0;</span><br><span class="line">&#125;</span><br><span class="line">else&#123;</span><br><span class="line">result = n+recur_sum(n-1);</span><br><span class="line">&#125;</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">int sum;</span><br><span class="line">sum=recur_sum(2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反汇编代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Main：</span><br><span class="line">          int sum;</span><br><span class="line">          sum=recur_sum(2);</span><br><span class="line">004010A8   push        2</span><br><span class="line">004010AA   call        @ILT+0(_recur_sum) (00401005)</span><br><span class="line">004010AF   add         esp,4</span><br><span class="line">004010B2   mov         dword ptr [ebp-4],eax</span><br><span class="line">   &#125;</span><br><span class="line">004010B5   pop         edi</span><br><span class="line">004010B6   pop         esi</span><br><span class="line">004010B7   pop         ebx</span><br><span class="line">004010B8   add         esp,44h</span><br><span class="line">004010BB   cmp         ebp,esp</span><br><span class="line">004010BD   call        __chkesp (004010e0)</span><br><span class="line">004010C2   mov         esp,ebp</span><br><span class="line">004010C4   pop         ebp</span><br><span class="line">004010C5   ret  </span><br><span class="line">recur_sum:</span><br><span class="line">int recur_sum(int n)&#123;</span><br><span class="line">00401020   push        ebp</span><br><span class="line">00401021   mov         ebp,esp</span><br><span class="line">00401023   sub         esp,44h</span><br><span class="line">00401026   push        ebx</span><br><span class="line">00401027   push        esi</span><br><span class="line">00401028   push        edi</span><br><span class="line">00401029   lea         edi,[ebp-44h]</span><br><span class="line">0040102C   mov         ecx,11h</span><br><span class="line">00401031   mov         eax,0CCCCCCCCh</span><br><span class="line">00401036   rep stos    dword ptr [edi]</span><br><span class="line">3:        int result;</span><br><span class="line">4:        if(n &lt;= 0)&#123;</span><br><span class="line">00401038   cmp         dword ptr [ebp+8],0</span><br><span class="line">0040103C   jg          recur_sum+27h (00401047)</span><br><span class="line">5:            result=0;</span><br><span class="line">0040103E   mov         dword ptr [ebp-4],0</span><br><span class="line">6:        &#125;</span><br><span class="line">7:        else&#123;</span><br><span class="line">00401045   jmp         recur_sum+3Eh (0040105e)</span><br><span class="line">8:            result = n+recur_sum(n-1);</span><br><span class="line">00401047   mov         eax,dword ptr [ebp+8]</span><br><span class="line">0040104A   sub         eax,1</span><br><span class="line">0040104D   push        eax</span><br><span class="line">0040104E   call        @ILT+0(_recur_sum) (00401005)</span><br><span class="line">00401053   add         esp,4</span><br><span class="line">00401056   mov         ecx,dword ptr [ebp+8]</span><br><span class="line">00401059   add         ecx,eax</span><br><span class="line">0040105B   mov         dword ptr [ebp-4],ecx</span><br><span class="line">9:        &#125;</span><br></pre></td></tr></table></figure></p><p>分析：首先在call递归函数之前，先把参数2压入了main函数栈帧所以第一次调用过程的栈示意图如下<br><img src="/img/pc2.png" alt="&quot;&quot;"><br>通过分析在调用recur_sum函数前，先把resur_sum的参数n压入栈中（在执行函数recur_sum过程体的时候可以很轻松的通过esp+8来访问），再把main函数的返回地址，也就是在调用recur_sum函数完成后的下一条指令的地址压入栈中（recur_sum执行完后，通过ret指令把esp+4中的值放到IR中，返回mian函数的控制），再把main栈帧的栈底指针压入栈中。<br>  第二层嵌套调用类似，示意图如下<br><img src="/img/pc3.png" alt="&quot;&quot;">          结论：递归调用的过程在栈中的表现形势就是函数栈帧一层层地往上叠加的，我们可以设想，如果n的值非常大，程序的内存开销将会变得非常大，从而影响程序的性能。 </p><p>2、LC3 机器语言（2进制表示、16进制表示、汇编指令级表示？仿真机器结构？机器指令执行过程？<br>(1)二进制代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0011000000000000</span><br><span class="line">0101001001100000</span><br><span class="line">0101100100100000</span><br><span class="line">0001100100101010</span><br><span class="line">1110010011111100</span><br><span class="line">0110011010000000</span><br><span class="line">0001010010100001</span><br><span class="line">0001001001000011</span><br><span class="line">0001100100111111</span><br><span class="line">0000001111111011</span><br><span class="line">1111000000100101</span><br></pre></td></tr></table></figure></p><p>   (2)16进制表示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">3000</span><br><span class="line">5260</span><br><span class="line">5920</span><br><span class="line">192A</span><br><span class="line">E4FC</span><br><span class="line">6680</span><br><span class="line">14A1</span><br><span class="line">1243</span><br><span class="line">193F</span><br><span class="line">03FB</span><br></pre></td></tr></table></figure></p><p>(1)LC-3汇编表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.ORIG x3000</span><br><span class="line">AND R1,R1,x0 ;clear R1, to be used for the running sum</span><br><span class="line">AND R4,R4,x0 ;clear R4, to be used as a counter</span><br><span class="line">ADD R4,R4,xA ;load R4 with #10, the number of times to add</span><br><span class="line">LEA R2,x0FC ;load the starting address of the data</span><br><span class="line">LOOP LDR R3,R2,x0 ;load the next number to be added</span><br><span class="line">ADD R2,R2,x1 ;increment the pointer</span><br><span class="line">ADD R1,R1,R3 ;add the next number to the running sum</span><br><span class="line">ADD R4,R4,x-1 ;decrement the counter</span><br><span class="line">BRp LOOP ;do it again if the counter is not yet zero</span><br><span class="line">HALT</span><br><span class="line">.END</span><br></pre></td></tr></table></figure></p><p>(2)仿真机器结构：<br>为LC3-sumilator：模仿了存储器和运算器两大部件，我们目前关注的也就是这两大部件，在进行一步步的调试之后，我们能直观地感受到数据是怎样一步步地在运算器和存储器中流动的。<br>(3)机器指令执行过程：<br>我们导入文件，就相当于把指令装进了地址，.ORIGx3000指令告诉了我们程序的第一条指令了地址x3000处，即修改了pc的值为x3000<br><img src="/img/pc4.png" alt="&quot;&quot;"><br>然后我们一步步运行机器指令<br><img src="/img/pc5.png" alt="&quot;&quot;"><br>这时我们看到X5260指令被装入了IR！ PC存了了下一条将执行的指令的地址<br>继续执行<br><img src="/img/pc6.png" alt="&quot;&quot;"><br>我们看到R0，R1，R4的空间分别被装入了 0，0， 10<br>再下一步<br>我们知道LC3汇编指令是LEA  R2 ,x3100，这一步带来改变就是寄存去R2的值变成了x3100，我们也能直观地看到<br><img src="/img/pc7.png" alt="&quot;&quot;"><br>然后再执行下一步指令 LDR R3，R2，#0<br>我们只到这条指令的意思是 M[R2] -&gt;R3<br>我们把地址x3100的值提前置为了1然后验证，果然R3的值被改为了1<br><img src="/img/pc8.png" alt="&quot;&quot;"><br>然后R2中的值加一<br>R3+R1-&gt;R1<br>R4-1-&gt;R4<br>验证结果真确<br>当R4中为0时，循环跳出，在各过程中，我们可以知道R1暂存sum的值，R4起到了计数器的作用</p><p>心得体会<br>总的来说，学习这门课太累了，一会又换平台的，一会又换工具的，一会又换机房的，我在想我要如何跳出这些工具，我用一些集成的工具，gcc，vs，vc似乎就已经能完成目前的学习需求，在最终理解知识点这些中间的载体好像并不是那么重要。我愿把这些时间花费在学习最接近我们的汇编语言上，总的来说，收获还是很大的。无论高级语言书写出来的多么高级的语法，最终也逃不过被转换为底层这些基本的数据传送，运算，比较的机器指令，从这一点上来讲，机器的世界是很简单的，我们去理解它也该如此简单。的确如此，我们单看一条汇编指令，很好理解。但是多条汇编语言组合的时候，对它的理解就变得困难了，好像只知道它在把数据丢过来丢过去，脱离了与之对比高级语言，它的语义就更加模糊了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、实验目的&lt;br&gt;通过各种变量赋值的的汇编实现、函数调用的汇编实现以及栈中对应的具体活动，从汇编语言角度理解C/C++机理以及相关代码是怎样被编译成汇编代码的。&lt;br&gt;二、实验环境&lt;br&gt;微机，配置Windows操作系统、GCC、LC3等工具。&lt;br&gt;三、实验内容&lt;br&gt;
      
    
    </summary>
    
      <category term="程序设计范式" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/"/>
    
    
  </entry>
  
  <entry>
    <title>通用栈结构设计</title>
    <link href="http://yoursite.com/2018/05/11/%E9%80%9A%E7%94%A8%E6%A0%88%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/05/11/通用栈结构设计/</id>
    <published>2018-05-11T11:13:40.000Z</published>
    <updated>2018-05-11T11:39:40.629Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;环境：c语言 + vc++6.0<br>&emsp;&emsp;一段基本的栈实现代码，针对特定的数据类型设计的栈结构，实现了基本的创建栈，撤销栈操作，入栈出栈操作。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">typedef struct&#123;      //栈结构定义</span><br><span class="line">int *element;  </span><br><span class="line">int size;</span><br><span class="line">int volume;</span><br><span class="line">&#125;stack;</span><br><span class="line"></span><br><span class="line">//初始化栈</span><br><span class="line">void create(stack*s)&#123;</span><br><span class="line">s-&gt;size=0;</span><br><span class="line">s-&gt;volume=3;</span><br><span class="line">s-&gt;element=malloc(s-&gt;volume*sizeof(int));</span><br><span class="line">&#125;</span><br><span class="line">//销毁栈</span><br><span class="line">void dispose(stack*s)&#123;</span><br><span class="line">free(s-&gt;element);</span><br><span class="line">&#125;</span><br><span class="line">//入栈</span><br><span class="line">void push(stack *s, int value)&#123;</span><br><span class="line">if(s-&gt;size == s-&gt;volume)&#123;</span><br><span class="line">s-&gt;volume *= 2;</span><br><span class="line">s-&gt;element = realloc(s-&gt;element,s-&gt;volume*sizeof(int));</span><br><span class="line">&#125;</span><br><span class="line">s-&gt;element[s-&gt;size] = value;</span><br><span class="line">s-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line">//出栈</span><br><span class="line">int pop(stack*s)&#123;</span><br><span class="line">//assert(s-&gt;size);</span><br><span class="line">s-&gt;size--;</span><br><span class="line">return s-&gt;element[s-&gt;size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//测试代码</span><br><span class="line">int main()&#123;</span><br><span class="line">stack st;</span><br><span class="line">create(&amp;st);</span><br><span class="line">push(&amp;st,3);</span><br><span class="line">push(&amp;st,2);</span><br><span class="line">push(&amp;st,1);</span><br><span class="line">for(int i = st.size;i&gt;0;i--)&#123;</span><br><span class="line">printf(&quot;%d\n&quot;,pop(&amp;st));</span><br><span class="line">&#125;</span><br><span class="line">dispose(&amp;st);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;可是这样做存在一定的问题，对所有的数据类型不通用，这种类型的栈结构的使用有很大的局限性。于是人们就开始思考了，能不能设计出一种通用的栈结构？使得对所有的数据类型通用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;string.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">typedef struct&#123;</span><br><span class="line">void *element;//此处为了实现数据通用，所以指针为void类型</span><br><span class="line">int size;//当前栈的大小</span><br><span class="line">int volume;//栈容量</span><br><span class="line">int len;//因为数据类型不确定，此处需要定义元素所占字节数</span><br><span class="line">&#125;stack;</span><br><span class="line"></span><br><span class="line">//创建栈</span><br><span class="line">void create(stack *s, int length)&#123;</span><br><span class="line">s-&gt;size = 0;</span><br><span class="line">s-&gt;volume = 3;</span><br><span class="line">s-&gt;len = length;</span><br><span class="line">s-&gt;element = malloc(s-&gt;volume*length);</span><br><span class="line">if(s-&gt;element==NULL)&#123;</span><br><span class="line">exit(1);</span><br><span class="line">printf(&quot;内存分配失败&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//销毁栈</span><br><span class="line">void dispose(stack *s)&#123;</span><br><span class="line">free(s-&gt;element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//入栈操作 arg1：s 栈地址 arg2: value 要push的值的地址</span><br><span class="line">void push(stack *s, void *value)&#123;</span><br><span class="line">void *addr;</span><br><span class="line">if(s-&gt;size == s-&gt;volume)&#123;</span><br><span class="line">s-&gt;volume *= 2;</span><br><span class="line">s-&gt;element = realloc(s-&gt;element,s-&gt;volume*s-&gt;len);</span><br><span class="line">&#125;</span><br><span class="line">addr = (char*)s-&gt;element + s-&gt;size*s-&gt;len;</span><br><span class="line">memcpy(addr,value,s-&gt;len);</span><br><span class="line">s-&gt;size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//出栈操作   arg1: s 栈地址   arg2: value  出栈值存放地址</span><br><span class="line">//此处设计的是通用栈结构，不知道数据类型，所以返回值的类型是不确定的，我们将弹出的数据存放在地址为value的空间中 </span><br><span class="line">void pop(stack *s, void *value)&#123;</span><br><span class="line">if(s-&gt;size&gt;0)&#123;</span><br><span class="line">void *addr;</span><br><span class="line">s-&gt;size--;</span><br><span class="line">addr = (char*)s-&gt;element+s-&gt;size*s-&gt;len;</span><br><span class="line">memcpy(value,addr,s-&gt;len);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">printf(&quot;栈中现在没有元素哦&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">//int型数据测试</span><br><span class="line">int array[5] = &#123;1,2,3,4,5&#125;;</span><br><span class="line">char *books[4] = &#123;&quot;西游记&quot;,&quot;红楼梦&quot;,&quot;水浒传&quot;,&quot;三国演义&quot;&#125;;</span><br><span class="line">int i;</span><br><span class="line">stack s;</span><br><span class="line">create(&amp;s, 4);        //初始化栈</span><br><span class="line">for(i = 0; i&lt;5; i++)&#123;</span><br><span class="line">push(&amp;s, &amp;array[i]);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">for(i = 0; i&lt;5; i++)&#123;</span><br><span class="line">pop(&amp;s, &amp;array[i]);</span><br><span class="line">printf(&quot;%d\n&quot;, array[i]);</span><br><span class="line">&#125;</span><br><span class="line">dispose(&amp;s);</span><br><span class="line">//字符串类型测试</span><br><span class="line"></span><br><span class="line">create(&amp;s,sizeof(char*));</span><br><span class="line">for(i = 0;i&lt;4;i++)&#123;</span><br><span class="line">push(&amp;s, &amp;books[i]);      //压入的是字符串的地址</span><br><span class="line">&#125;</span><br><span class="line">for(i = 0;i&lt;4;i++)&#123;</span><br><span class="line">pop(&amp;s, &amp;books[i]);</span><br><span class="line">printf(&quot;%s\n&quot;, books[i]);</span><br><span class="line">&#125;</span><br><span class="line">dispose(&amp;s);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;我们可以看到，在对int和字符串经行入栈出栈操作，使用的是通一个栈结构，我们代码的重用性更强了，它不仅试用与普通数据类型，也适用于复杂的数据类型。它带给我们的思考就是，贯穿软件设计的始末，我们如何设计更为通用的东西出来，以应对变化的外界环境。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;环境：c语言 + vc++6.0&lt;br&gt;&amp;emsp;&amp;emsp;一段基本的栈实现代码，针对特定的数据类型设计的栈结构，实现了基本的创建栈，撤销栈操作，入栈出栈操作。&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;
      
    
    </summary>
    
      <category term="程序设计范式" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/"/>
    
    
      <category term="数据结构 c语言" scheme="http://yoursite.com/tag/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>说说</title>
    <link href="http://yoursite.com/2018/05/07/%E8%AF%B4%E8%AF%B4/"/>
    <id>http://yoursite.com/2018/05/07/说说/</id>
    <published>2018-05-07T10:33:39.000Z</published>
    <updated>2018-05-07T10:43:15.166Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;连续两次比赛失利，说不难过是假的，卧槽，直到比赛结果出来，我才知道支撑我动力的一直是比赛。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;连续两次比赛失利，说不难过是假的，卧槽，直到比赛结果出来，我才知道支撑我动力的一直是比赛。&lt;/p&gt;

      
    
    </summary>
    
      <category term="垃圾场" scheme="http://yoursite.com/categories/%E5%9E%83%E5%9C%BE%E5%9C%BA/"/>
    
    
      <category term="吐槽" scheme="http://yoursite.com/tag/%E5%90%90%E6%A7%BD/"/>
    
  </entry>
  
  <entry>
    <title>软件设计师考点</title>
    <link href="http://yoursite.com/2018/05/05/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E8%80%83%E7%82%B9/"/>
    <id>http://yoursite.com/2018/05/05/软件设计师考点/</id>
    <published>2018-05-05T13:25:03.000Z</published>
    <updated>2018-05-05T14:32:08.265Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;开始研究软考了，根据考纲要求，软考涉及到的课程有计算机组成与体系结构、操作系统、数据库系统、计算机网络、信息安全、软件工程、项目管理、面向对象、数据结构与算法基础、程序设计语言（c,c++,java）、多媒体基础、法律法规与标准化、专业英语。<br>&emsp;&emsp;这样一看其实考查的课程还是十分多的，知识面广了，考察必有侧重点。网上查阅则料，根据历年考题分析，还真有一点的重点和规律。<br><img src="/img/softwarekn.png" alt="“swknowledge”"><br>&emsp;&emsp;总的来说上午的考试对软件工程，面向对象，数据结构与算法基础的要求应该是比较高的，占的分值也比较大。这三门中目前还没有学习软件工程方法相关知识，借一本他们的书先看起来吧。。。。。。数据结构和算法，真是令人最头疼的一个点，虽说学校开设了一些课程，但自己平时写代码的话，设计不到算法之类的，所以忘得差不多了。<br>&emsp;&emsp;下午的考试就是大题了，涉及到的题型比较固定，有数据流图、数据库设计、UML建模、c语言算法、（java，c++）程序设计。<br>&emsp;&emsp;之所以决定它难，是因为并不了解它吧。现在有了总的知识框架，考个十多次应该能过吧？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;开始研究软考了，根据考纲要求，软考涉及到的课程有计算机组成与体系结构、操作系统、数据库系统、计算机网络、信息安全、软件工程、项目管理、面向对象、数据结构与算法基础、程序设计语言（c,c++,java）、多媒体基础、法律法规与标准化、专业英语。&lt;br&gt;
      
    
    </summary>
    
      <category term="软件设计师" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88/"/>
    
    
      <category term="软考" scheme="http://yoursite.com/tag/%E8%BD%AF%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>四月总结及五月规划</title>
    <link href="http://yoursite.com/2018/04/27/%E5%9B%9B%E6%9C%88%E6%80%BB%E7%BB%93%E5%8F%8A%E4%BA%94%E6%9C%88%E8%A7%84%E5%88%92/"/>
    <id>http://yoursite.com/2018/04/27/四月总结及五月规划/</id>
    <published>2018-04-27T03:41:04.000Z</published>
    <updated>2018-08-26T01:41:45.387Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;大数据比赛结束了，深夜里反反复复看着团队努力的成果，骄傲和自豪久久没有褪去。这种感觉并不是源自使用了某种技术，做的多么的好，多么的优秀，而是我尽力了，大家都在努力。呀，回头一看做过的事情，也并没有写多少行代码，好像那些个技术或者是算法也就是那么一回事嘛。为什么当初花费了大量的时间。。。。。。四月份要结束了，假期给自己定下了目标，中级软件设计师也还没完成多少，只能推迟到五月了。<br>&emsp;&emsp;这两天老师急着赶进度，听着老师说，你还得去了解这个，还得去了解那个。的却，我都想了解，甚至全tm都想学好。我一直是抱着以无用之用的态度在学，通俗说就是学习不分有用和无用，这是我在一次讲座上学习的。没错，这是优点，可那种学习程度把握不好也是很致命的。我时常问自己”能学那么多么，计算机科学领域太广了”，想学好某一领域，我必须有所舍弃啊。<br>&emsp;&emsp;五月及以后的主线应是以软件设计师和大数据为主学校课程为辅，其实软考设计知识点本科阶段大都是涉及的，从计算机原理，操作系统，网络安全到数据结构，算法等等，我该怎样快速学习这些课程，这里先打个问号。<br>&emsp;&emsp;紧接着又要迎来计算机系统基础和概率统计的复习了。我不是冲着学校考试的，计算机系统基础作为软件设计师考察重点而概率统计作为大数据应用的基础，是我要着重花时间掌握的。复习阶段可能持续到5月10号左右，5月10号往后程序设计范式为重点。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;大数据比赛结束了，深夜里反反复复看着团队努力的成果，骄傲和自豪久久没有褪去。这种感觉并不是源自使用了某种技术，做的多么的好，多么的优秀，而是我尽力了，大家都在努力。呀，回头一看做过的事情，也并没有写多少行代码，好像那些个技术或者是算法也就是那么一回事
      
    
    </summary>
    
      <category term="总结" scheme="http://yoursite.com/categories/%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="总结 规划" scheme="http://yoursite.com/tag/%E6%80%BB%E7%BB%93-%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>开头难</title>
    <link href="http://yoursite.com/2018/04/25/%E5%BC%80%E5%A4%B4%E9%9A%BE/"/>
    <id>http://yoursite.com/2018/04/25/开头难/</id>
    <published>2018-04-25T10:24:02.000Z</published>
    <updated>2018-05-08T13:33:46.795Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;早就在说想写博客了，可一直给自己找了各种理由没能付诸于实际。前几天花了几个小时在github上用hexo搭起了一个博客框架暂时就这样吧，如果以后写经验的时候存放图片等静态资源很麻烦，再换地方。<br>&emsp;&emsp;好吧。我一直很头疼写作，因为觉得费时又费力，这种想法可能和我不喜欢做笔记一样傻不拉唧吧。现在我终于尝到苦果了，我觉的我学的东西很乱，在大脑里面乱占内存，可我又没有指针指向他们。我要改变自己了，我因羡慕有自己博客的大牛而搭建博客，我总得为自己留下点什么吧。<br>&emsp;&emsp;昨晚睡前一直头脑风暴，我到底写啥？似乎得到了满意的结果，安然睡去了。我敢说我昨晚上想到的点子要比我接下来要写的完美的多，可现在全然想不起了。。。。。。<br>&emsp;&emsp;我现在能想到的大致分为两个路线：写写生活感悟和学习总结。<br>&emsp;&emsp;多好啊，我也有自己的博客了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;早就在说想写博客了，可一直给自己找了各种理由没能付诸于实际。前几天花了几个小时在github上用hexo搭起了一个博客框架暂时就这样吧，如果以后写经验的时候存放图片等静态资源很麻烦，再换地方。&lt;br&gt;&amp;emsp;&amp;emsp;好吧。我一直很头疼写作，因
      
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
</feed>
